---
title: "Strings"
output:
  html_document:
    toc: true
    number_sections: true
---


<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 8px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Strings


## Introduction（準備）
_準備としてpackageを読み込む．_


```{r}
library(tidyverse)
library(stringr)
```

## String basics（文字列の基本）

* 文字列の作成： ダブルクォート（"） またはシングルクォート（'） で文字を囲う．

```{r}
string1 <- "This is a string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
```

* 「 " 」自身を文字列に含む場合は，エスケープ文字（「```\``` 」，バックスラッシュ）をつける．

_google chromeで見ると，バックスラッシュはチャンク中で「￥」と表示される．設定の問題か・・・？_


```{r}
double_quote <- "\"" # or '"'
single_quote <- '\'' # or "'"
```

_R Markdownで特殊文字（正規表現の記号など）を記述する場合などにもエスケープ文字（```\```）を付加する必要がある．_

* エスケープ文字を含む文字列をそのまま表示した場合：
```{r}
x <- c("\"", "\\")
x
```

* ```writeLines()```関数を用いた場合： _意図した文字列が表示される_
```{r}
writeLines(x)

```

__Other special characters（その他の特殊文字）__  
* ```\n```：　改行
* ```\t```：　タブ
* ```\u00b5```など：　ラテン文字以外の文字の表現（ギリシア文字など，文字コードを使って表現する）

```{r}
x <- "\u00b5"
x
```

* 文字列ベクトル
```{r}
c("one", "two", "three")
```

### stringr package（文字列を扱う関数）

色々な文字列関数があるが，「```stringr```パッケージ」に含まれる「```str_xxxx()```」系関数を用いると分かりやすい．

### String length（文字列の長さ）

*  ```str_length()```： 文字列の長さを表す．
```{r}
str_length(c("a", "R for data science", NA))
```

### Combining strings（文字列の結合）

* ```str_c```： 文字列を結合する．「```sep=```」で区切り文字の指定．
```{r}
str_c("x", "y")
str_c("x", "y", "z")
str_c("x", "y", sep = ", ")

```


```str_c()``` 関数はベクトルを返す．

```{r}
str_c(c("1","2","3"),c("a","b","c"),c("X","Y","Z"))
```

```str_c()``` 関数の入力値ベクトルの長さが異なる場合：

入力値の中で最も長い文字列ベクトルの長さに合わせて，短い長さの入力値（文字列ベクトル）を「リサイクルして」使う．

```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")

str_c(c("1","2","3"),c("a","b","c","d","e","f"),c("A","B"))

# 最も長いベクトルの長さが他のベクトルの長さの倍数になっていないときはWarningが出る．

str_c(c("1","2","3"),c("a","b","c","d","e"),c("A","B"))
```


長さが0の文字列は何もないものとして扱われる．

```{r}
# if関数の中がFALSEなので，str_c() 関数の中の最後の文字列は長さ0になる （" and HAPPY BIRTHDAY" は含まれない）．

name <- "Hadley"
time_of_day <- "morning"
birthday <- FALSE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)

```


* ```collapse=```：　文字列ベクトルを結合して一つの文字列に変換したいときに使う．

```{r}
str_c(c("x", "y", "z"), collapse = ", ")
str_c(c("x", "y", "z"), collapse = "")
```


* ```str_replace_na()```： 欠損値（NA）を，「NA」という文字列で表現する．

```{r}
x <- c("abc", NA)
x
str_replace_na(x)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")

```

### Subsetting strings（文字列の部分列）

* ```str_sub()```：　文字列の部分列を取り出す． 
文字列ベクトル，開始位置，終了位置を指定する．

```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

# 負の値は後ろから数えることを意味する．
str_sub(x, -3, -1) # 後ろから3番目〜後ろから1番目を取り出す．

# 文字列が短くても問題ない（取り出せるだけ取り出す）．
str_sub("ab", 1, 5)
```

文字列の編集に```str_sub()```　を用いる例：

```{r}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1)) 
# 各文字列の先頭の文字を小文字に変換する．
x
```

### Locales（ロケール）

ロケール◆言語別または地域別に分けられた設定情報

```{r}
# Turkish has two i's: with and without a dot, and it
# has a different rule for capitalising them:

# 特殊文字（トルコ語）を含むため，文字化けが発生する．

str_to_upper(c("i", "??"))

# 特殊文字（トルコ語）を含むため，文字化けが発生する．

str_to_upper(c("i", "??"), locale = "tr")


```

The locale is specified as a ISO 639 language code, which is a two or three letter abbreviation. If you don’t already know the code for your language, Wikipedia has a good list. If you leave the locale blank, it will use the current locale, as provided by your operating system.

Another important operation that’s affected by the locale is sorting. The base R order() and sort() functions sort strings using the current locale. If you want robust behaviour across different computers, you may want to use str_sort() and str_order() which take an additional locale argument:

```{r}
x <- c("apple", "eggplant", "banana")

str_sort(x, locale = "en")  # English

str_sort(x, locale = "haw") # Hawaiian
```

## Matching patterns with regular expressions（正規表現による検索）

正規表現を用いた検索のために，以下の関数を用いる：

* ```str_view()```  
* ```str_view_all()```


```str_view()```は検索結果を一つだけ，```str_view_all()```は全ての検索結果を示す．


### Basic matches（簡単な検索）


 ```str_view()```を用いた検索例：  

* 簡単な文字列の検索：  

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "an")
```


* 「 ```.``` 」：　任意の1文字を表す．

```{r}
str_view(x, ".a.")
```



* 「 ```.``` 」（ピリオド）自体を文字として検索する場合：

正規表現としては「 ```\.``` 」 （エスケープ文字を使う）．

しかしこれを検索文字とするとエラーになる．

```
str_view(c("abc", "a.c", "bef"), "a\.c")

Error: '\.' is an unrecognized escape in character string starting ""a\."
```

正しくは，「```\\.```」を検索文字とする．



```{r}
# To create the regular expression, we need \\
dot <- "\\."

# But the expression itself only contains one:
writeLines(dot)

# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
```


* 「 ```\``` 」（バックスラッシュ）自体を文字として検索する場合：

→　```\```に対するエスケープ文字の表現として```\\```，更に検索キーの```\```の表現として```\\```．

これらを合わせて```\\\\```を検索キーとする．

```{r}
x <- "a\\b"
writeLines(x)

str_view(x, "\\\\")
```


### Anchors（検索文字列の位置の指定　―　文字列の最初か終わりか　―）

* ```^```：　文字列の最初に一致するもの  
* ```$```：　文字列の終わりに一致するもの

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "^a")

str_view(x, "a$")
```

* 文字列の完全一致： ```^```と```$```で挟む．
```{r}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple") # 部分一致もヒットする．
```

```{r}
str_view(x, "^apple$") # 完全に一致する文字列だけヒットする．
```


* ```\b```：　単語の区切りを示す．

```{r}
x<-c("sum","summarize","summary","a sum of the numbers")
str_view(x,"\\bsum\\b")
```


### Character classes and alternatives（文字クラスと選択）

__Character classes（文字クラス）__  
1文字以上の文字列にマッチする特殊文字

* ```\d```：　任意の数値  
* ```\s```：　任意の空白文字（スペース，タブ，改行）  
* ```[abc]```：　a, b, またはc  
* ```[^abc]```：　a, b, c のいずれでもない文字  

*エスケープ文字を含む場合，実際に検索する際には「```\\d```」「```\\s```」などとする必要がある．*

```{r}
# 文字列の頭から検索して最初にマッチした文字だけが検索結果として挙がる．
x<-c("1a2b3c","9z8y ax6wxry","s9gl8\nsax","345+dgx\tr")
str_view(x,"\\d")
str_view(x,"\\s")
str_view(x,"[abc]")
str_view(x,"[^abc]")
```


__Alternative（選択）__  

* ``` | ```：　左右の文字列のいずれかにマッチするものを探す．
演算子としての優先順位が低いため，```()```でくくって範囲を明確にする．

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
str_view(c("abcxyz","abcyz","abxyz"),"abc|xyz") # "abc" "xyz"のいずれかがヒットする．

# "abcyz"か"abxyz"のいずれかを探したい場合は，"ab(c|x)yz"のように，カッコでくくる．
str_view(c("abcxyz","abcyz","abxyz"),"ab(c|x)yz")

```

### Repetition（繰り返し）

直前の文字をいくつ繰り返すかを表す．

* ```?```: 0個か1個  
* ```+```: 1個以上  
* ```*```: 0個以上  

```{r}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, 'C[LX]+')

y<-"ABCDE"
str_view(y,"CC?")
str_view(y,"CC+")
str_view(y,"CC*")

# これらの演算子は優先順位が高い．
str_view(c("colour","color"),"colou?r")

```


繰り返しの回数を指定することも可能．

* ```{n}```: n回  
* ```{n,}```: n回以上  
* ```{,m}```: m回以下  
* ```{n,m}```: n回〜m回  

```{r}
str_view(x, "C{2}")
str_view(x, "C{2,}")
str_view(x, "C{2,3}")
```

デフォルトでは，なるべく長い文字列にマッチするよう結果を返す．  
```?```を使って，なるべく短い文字列にマッチするよう結果を返すようにすることもできる．

```{r}
str_view(x, 'C{2,3}?')
str_view(x, 'C[LX]+?')
```

### Grouping and backreferences（グループの定義と後方参照）

* ```()```を使ったグループの定義と後方参照
```()```でグループを定義して検索する．  
```\1```, ```\2```などで，後から検索結果を参照できる．

```{r}
# 任意の2文字の直後に同じ2文字が繰り返される文字列を検索
str_view(fruit, "(..)\\1", match = TRUE)
# 胡瓜は果物なのか・・・？
```

## Tools（更に複雑な検索）
### Detect matches（マッチの検出）

* ```str_detect()```：　検索対象中に検索キーがあるかないかを返す．
（検索対象と同じ長さの論理値ベクトルを返す）

```{r}
x <- c("apple", "banana", "pear")
str_detect(x, "e")
```

論理値は0 or 1と同じなので，計算することができる．
```{r}
# How many common words start with t?
sum(str_detect(words, "^t"))

# What proportion of common words end with a vowel（母音）?
mean(str_detect(words, "[aeiou]$"))
```


複雑な検索条件　⇒　```str_detect()```と論理演算子を組み合わせるとよい．

* 母音を含まない単語を全て探す例：

```{r}
# Find all words containing at least one vowel, and negate
no_vowels_1 <- !str_detect(words, "[aeiou]")

# Find all words consisting only of consonants（子音） (non-vowels)
# ^ = 語頭，[^aeiou] = 子音，+ = 1文字以上続く，$ = 語末
# 語頭から語末まで子音が並ぶ単語を探す表現
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")

identical(no_vowels_1, no_vowels_2) # いずれの方法でも結果は一致する．

```

* 条件を満たす文字列の抽出：```str_detect()```または```str_subset()```を使う．

```{r}
words[str_detect(words, "x$")]

str_subset(words, "x$")

```

* データフレームに対する処理：```filter()```を使う．

```{r}
df <- tibble(
  word = words, 
  i = seq_along(word)
)
df %>% 
  filter(str_detect(words, "x$"))
```

* ```str_count()```：　条件に合う文字列がいくつあるかを示す．

```{r}
x <- c("apple", "banana", "pear")
str_count(x, "a")

mean(str_count(words, "[aeiou]"))

```

* ```str_count()```と```mutate()```の組み合わせ例：

```{r}
df %>% 
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]")
  )
```

検索結果はオーバーラップしない．

* ```"abababa"```の中に```"aba"```はいくつある？

```{r}
# いくつあるか数える
str_count("abababa", "aba")

# 検索結果はどうなっているか？
str_view_all("abababa", "aba")

# 「あばばばば」は芥川龍之介の小説．

```
真ん中の```"aba"```はマッチしていない．1つ目の検索結果と被るので．

### Extract matches（マッチした文字列の抽出）

* ```str_extract()```：　検索でマッチした文字列を返す（最初にマッチした1つだけ）．
* ```str_extract_all()```：　検索でマッチした全ての文字列を返す．   
  
* 文字列ベクトル```sentences```から色の単語を抽出する例．

```{r}
length(sentences)

head(sentences)

```

まず，色の単語を並べた文字列を作成する（いずれかの単語を含む検索を行うキー）．
```{r}
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match # 「coloursに含まれるいずれかの単語」を示す検索キー
```

```colour_match```の中の単語いずれかがあればそれらを抽出する．
```{r}
# sentencesのうち，colour_matchの中にある単語を含む文章を抽出
has_colour <- str_subset(sentences, colour_match)

# 抽出された文章の中にある色の単語を抽出
matches <- str_extract(has_colour, colour_match)
head(matches)
```

全ての検索結果を抽出する例（```str_view_all()```）：
```str_view_all()```の返り値はリスト型になる．
```{r}
# sentencesの中から色の単語を2つ以上含む文章を抽出
more <- sentences[str_count(sentences, colour_match) > 1]
head(more)

# colour_matchの中でmoreに含まれる単語を確認
str_view_all(more, colour_match)

# colour_matchの中でmoreに含まれる単語を抽出
# 最初にマッチした一つだけ
str_extract(more, colour_match)

# colour_matchの中でmoreに含まれる単語を全て抽出
# 返り値はリスト型
str_extract_all(more, colour_match)

```

```simplify=TRUE```：　返り値がマトリックス型になる．

```{r}
str_extract_all(more, colour_match, simplify = TRUE)

x <- c("a", "a b", "a b c")
str_extract_all(x, "[a-z]")
str_extract_all(x, "[a-z]", simplify = TRUE)

y<-c("abcdef","bcde","fg")
str_extract_all(y, "[a-z].?")
str_extract_all(y, "[a-z].?", simplify = TRUE)

```

### Grouped matches

```{r}
# "a"または"the"の後にスペースがあり，その後スペース以外の文字が1つ以上続く場合は名詞とみなして検索する．
# 名詞検索のための検索キー
noun <- "(a|the) ([^ ]+)"

# 名詞を含む文章を抽出
has_noun <- sentences %>%
  str_subset(noun) %>%
  head(10) # 最初の10個だけ

has_noun

# 抽出した文章中に含まれる名詞を抽出
has_noun %>% 
  str_extract(noun)
```

* ```str_match()```：　マッチした文字列の各要素を返す（マトリックス型）．
* ```str_match()_all```：　マッチした全て文字列の各要素を返す．


```{r}
has_noun %>% 
  str_match(noun)
# 検索条件がpoorなので，名詞以外の品詞もマッチしている・・・
```

* ```tidyr::extract()```：　```tibble```で作成したデータフレームに対して```str_match()```と同様の働きをする．簡単．

```{r}
# カラムの名前を付ける必要がある（この例ではc("article", "noun")）
tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", 
    remove = FALSE
  )
```

### Replacing matches（置換）


* ```str_replace()```  
* ```str_replace()_all```  

文字列を検索して置換する．

```{r}
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")

str_replace_all(x, "[aeiou]", "-")

# 検索・置換条件をベクトルで複数与える
x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))

# 後方参照を使って単語の順序を入れ替える例．
# 3つの単語の塊をとってきて，2つ目と3つ目の単語を入れ替える．
#「str_replace」なので，最初にマッチしたものだけ．
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)


```

### Splitting（分割）


* ```str_split()```：　文字列を分割する．返り値はリスト型．

```{r}
sentences %>%
  head(5) %>% 
  str_split(" ") # スペースを区切り文字として分割
```

```simplify=TRUE```：　返り値をマトリックス型にする．
```{r}
sentences %>%
  head(5) %>% 
  str_split(" ", simplify = TRUE)  # simplify=TRUEでマトリックス型の返り値になる．

```

### Find matches（マッチする文字列の出現場所）

* ```str_locate()```  
* ```str_locate_all()```  
⇒マッチする文字列の出現場所（開始及び終了の場所）  を示す．

```{r}
sentences %>% head(10) %>%
  str_locate("the")
```

## Other types of pattern（その他のパターン）

* ```regex()```：　検索条件を詳細に設定する．  
* ```ignore_case=TRUE```：　大文字 / 小文字を区別しない．
```{r}
bananas <- c("banana", "Banana", "BANANA")

str_view(bananas, "banana") #小文字のみマッチする
str_view(bananas, regex("banana", ignore_case = TRUE)) # 大文字もマッチする
```

* ```multiline=TRUE```：　```^```や```$```を含む検索時に，改行を考慮する．

```{r}
x <- "Line 1\nLine 2\nLine 3"

str_extract_all(x, "^Line")[[1]]
str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]
```

* ```comments=TRUE```：　複雑な正規表現を記述する際にコメントを挿入できる．  
```#```でコメント挿入．  
```#```以降のスペースは全て無視されるため，スペースを検索する場合はエスケープする必要がある（```\\ ```）．

```{r}
phone <- regex("
  \\(?     # optional opening parens
  (\\d{3}) # area code
  [)- ]?   # optional closing parens, dash, or space
  (\\d{3}) # another three numbers
  [ -]?    # optional space or dash
  (\\d{3}) # three more numbers
  ", comments = TRUE)

str_match("514-791-8141", phone)
```

* ```dotall=TRUE```：　```.```が```\n```も含めて全ての文字にマッチする設定．
```{r}
x <- "Line 1\nLine 2\nLine 3"

str_extract_all(x, "Line [0-9].")[[1]]
str_extract_all(x, regex("Line [0-9].", dotall = TRUE))
```

__```regex()```以外では・・・__  
* ```fixed()```：　指定した文字列そのままを検索キーとする．  
正規表現も変換されずそのままの文字列として検索される．  
実行速度が速くなる．

```{r}
# fixedの指定ありなしでの実行速度比較
microbenchmark::microbenchmark(
  fixed = str_detect(sentences, fixed("the")),
  regex = str_detect(sentences, "the"),
  times = 20
)
```

```{r}
# 他の例
microbenchmark::microbenchmark(
  fixed = str_detect(sentences, fixed(".")),
  regex = str_detect(sentences, "\\."),
  times = 20
)

identical(str_detect(sentences, fixed(".")),str_detect(sentences, "\\.")) # 結果は一致する．

```


```fixed()```を英語以外の文字に用いる場合は注意が必要．  
同じ文字を表すのに複数の方法がある場合がある．

```{r}
a1 <- "\u00e1"
a2 <- "a\u0301"
c(a1, a2)

a1 == a2 # 見た目は同じでも定義の仕方が違うので異なるものと認識．
```

* ```coll()```：　見た目が同じなら定義の仕方が違っても同じものと認識．  

```{r}
str_detect(a1, fixed(a2))
str_detect(a1, coll(a2))
```

```{r}
# That means you also need to be aware of the difference
# when doing case insensitive matches:
# i <- c("I", "??", "i", "??")
i <- c("I", "\u0130", "i", "\u0131")
i

str_subset(i, coll("i", ignore_case = TRUE))

str_subset(i, coll("i", ignore_case = TRUE, locale = "tr"))
```

デフォルトのロケールの確認：
```{r}
stringi::stri_locale_info()

```

* ```coll()``` では速度が落ちる （```regex()``` ， ```fixed()```との比較）.

* ```boundary()``` :境界を指定
```{r}
x <- "This is a sentence."
str_view_all(x, boundary("word"))

str_extract_all(x, boundary("word"))

```


## Other uses of regular expressions（正規表現の他の使用法）

There are two useful function in base R that also use regular expressions:

```apropos()```：使用可能な全てのオブジェクトを示す．
```{r}
apropos("replace")

```


```dir()```：ディレクトリ中の全てのファイルを示す．
```{r}
head(dir(pattern = "\\.Rmd$"))

```

(If you’re more comfortable with “globs” like *.Rmd, you can convert them to regular expressions with glob2rx()):


## stringi

* より網羅的
* 関数の数は232（stringrは43）
* 関数は```stri_```で始まる



